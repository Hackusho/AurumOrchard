.exit
})();
  console.log({ hash: rcpt.transactionHash, gasUsed: rcpt.gasUsed.toString() });
  const rcpt = await tx.wait();
  const tx = await exe.runSimpleFlash(WETH, amount, params, { gasLimit: 2_000_000 });
  console.log("Static OK → sending tx…");
  await exe.runSimpleFlash.staticCall(WETH, amount, params);
  console.log("caller:", (await signer.getAddress()).toLowerCase());
  console.log("owner:", (await exe.owner()).toLowerCase());
  );
    [pathA, pathB, minOutA, minOutB, minProfitWei]
    ["address[]","address[]","uint256","uint256","uint256"],
  const abi = ethers.AbiCoder.  const params = abi.encode(
y+profit on return
  const minOutB = amount + premiumPad + minProfitWei; // require full repa
  const minOutA = 0n;                              // wide first hop
  const minProfitWei = gasWei + premiumPad + safety;
  const safety = 10_000_000_000_000n;              // 0.00001 WETH
  const premiumPad = (amount * 7n) / 10000n;       // ~7 bps cushion
  const gasWei = price * 600000n;                  // rough gas
  const price = (fee.gasPrice ?? fee.maxFeePerGas ?? 0n);
  const fee = await ethers.provider.getFeeData();
  const pathB  = [USDCe, WETH]; // Sushi leg
  const pathA  = [WETH, USDCe]; // UniV3 leg (your contract uses UNISWAP_FEE=3000)
  const amount = BigInt(process.env.FLASH_AMOUNT_WEI || "10000000000000"); // 0.00001 WETH
  const exe    = await ethers.getContractAt("FlashloanExecutor", exeAddr, signer);
  const signer = new ethers.Wallet(process.env.SEED_KEY, ethers.provider); // owner/sender
  const USDCe = norm("0xFF970A61A04b1cA14834A43f5dE4533eBDDB5CC8"); // matches your contract constants
  const WETH  = norm("0x82aF49447D8a07e3bd95BD0d56f35241523fBab1");
  const exeAddr = process.env.FLASH_EXECUTOR_ADDRESS;
  const norm = (a) => ethers.getAddress
(async () => {
.exit
})();
  console.log("Tx:", rcpt.transactionHash, "GasUsed:", rcpt.gasUsed.toString());
  const rcpt = await tx.wait();
  const tx = await exe.runSimpleFlash(WETH, amount, params, { gasLimit: 2_000_000 });
  console.log("Static OK → sending tx…");
  await exe.runSimpleFlash.staticCall(WETH, amount, params);
  // dry-run (free): reverts if not profitable or wiring wrong
  );
    [pathA, pathB, minOutA, minOutB, minProfitWei]
    ["address[]","address[]","uint256","uint256","uint256"],
  const params = abi.encode(
  const abi = ethers.AbiCoder.defaultAbiCoder();
rn leg
  const minOutB = amount + premiumPad + minProfitWei;      // demand full repay+profit on retu
  const minOutA = 0n;                                      // keep wide; final guard below
  const minProfitWei = gasWei + premiumPad + safety;
mPad = (amount * 7n) / 10000n;  // ~7 bps cushion
  const premiu
  const gasWei = (fee.gasPrice ?? fee.maxFeePerGas ?? 0n) * 600000n;
  const fee = await ethers.provider.getFeeData();
  // profit guard = rough gas + tiny cushion; premium checked in-contract
  const pathB  = [USDCe, WETH];  // Sushi leg
  const pathA  = [WETH, USDCe];  // Uniswap v3 leg (fee=3000 in contract)
  const amount = BigInt(process.env.FLASH_AMOUNT_WEI || "10000000000000"); // 0.00001 WETH
  const exe    = await ethers.getContractAt("FlashloanExecutor", exeAddr, signer);
  const signer = new ethers.Wallet(process.env.SEED_KEY, ethers.provider);
  const USDCe = norm("0xFF970A61A04b1cA14834A43f5dE4533eBDDB5CC8");
  const WETH  = norm("0x82aF49447D8a07e3bd95BD0d56f35241523fBab1");
  // use your contract constants: WETH + USDC.e (bridged)
  const exeAddr = process.env.FLASH_EXECUTOR_ADDRESS;
(  const norm = (a) => ethers.getAddress(a.toLowerCase());
// npx hardhat console --network arbitrumMainnet